
import java.awt.Font;
import java.awt.FontFormatException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Bîtcă Adrian-Iulian
 */

public class FereastraPrincipala extends javax.swing.JFrame {

    public static Font FontMenu = null;
    public static Font FontText = null;
            
    /**
     * Creates new form FereastraPrincipala
     */
    public FereastraPrincipala() {
        try {
            InputStream fisier;
            fisier = getClass().getResourceAsStream("Ubuntu-R.ttf");
            Font baseFontMenu = Font.createFont(Font.PLAIN, fisier);
            FereastraPrincipala.FontMenu = baseFontMenu.deriveFont(14f);
            fisier = getClass().getResourceAsStream("DejaVuSansMono.ttf");
            Font baseFontText = Font.createFont(Font.PLAIN, fisier);
            FereastraPrincipala.FontText = baseFontText.deriveFont(14f);
        } catch (FontFormatException | IOException ex) {
            Logger.getLogger(FereastraPrincipala.class.getName()).log(Level.SEVERE, null, ex);
        }
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        GrupButoane = new javax.swing.ButtonGroup();
        Instructiuni = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        ListaNumere = new javax.swing.JTextArea();
        Merge = new javax.swing.JRadioButton();
        Quick = new javax.swing.JRadioButton();
        Insertion = new javax.swing.JRadioButton();
        Bubble = new javax.swing.JRadioButton();
        Selection = new javax.swing.JRadioButton();
        Swap = new javax.swing.JRadioButton();
        Heap = new javax.swing.JRadioButton();
        BST = new javax.swing.JRadioButton();
        Counting = new javax.swing.JRadioButton();
        Bucket = new javax.swing.JRadioButton();
        Radix = new javax.swing.JRadioButton();
        Flipping = new javax.swing.JRadioButton();
        Intermediari = new javax.swing.JCheckBox();
        EtichetaComplexitate = new javax.swing.JLabel();
        EtichetaCNef = new javax.swing.JLabel();
        EtichetaCMed = new javax.swing.JLabel();
        EtichetaCFav = new javax.swing.JLabel();
        Nefavorabil = new javax.swing.JTextField();
        Mediu = new javax.swing.JTextField();
        Favorabil = new javax.swing.JTextField();
        Executa = new javax.swing.JButton();
        Separator = new javax.swing.JSeparator();
        EtichetaRezultat = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        ListaRezultat = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Algoritmi de sortare");
        setFocusCycleRoot(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowOpened(java.awt.event.WindowEvent evt) {
                formWindowOpened(evt);
            }
        });

        Instructiuni.setFont(FontMenu);
        Instructiuni.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        Instructiuni.setText("Introduceți un vector de numere întregi pentru sortare");
        Instructiuni.setFocusable(false);

        jScrollPane1.setFocusable(false);
        jScrollPane1.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N

        ListaNumere.setColumns(20);
        ListaNumere.setFont(FontText);
        ListaNumere.setLineWrap(true);
        ListaNumere.setRows(5);
        ListaNumere.setToolTipText("Numerele pot fi separate prin orice caracter");
        ListaNumere.setCursor(new java.awt.Cursor(java.awt.Cursor.TEXT_CURSOR));
        ListaNumere.setNextFocusableComponent(Merge);
        jScrollPane1.setViewportView(ListaNumere);

        GrupButoane.add(Merge);
        Merge.setFont(FontMenu);
        Merge.setSelected(true);
        Merge.setText("Merge");
        Merge.setNextFocusableComponent(Quick);
        Merge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MergeActionPerformed(evt);
            }
        });

        GrupButoane.add(Quick);
        Quick.setFont(FontMenu);
        Quick.setText("Quick");
        Quick.setNextFocusableComponent(Insertion);
        Quick.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                QuickActionPerformed(evt);
            }
        });

        GrupButoane.add(Insertion);
        Insertion.setFont(FontMenu);
        Insertion.setText("Insertion");
        Insertion.setNextFocusableComponent(Bubble);
        Insertion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                InsertionActionPerformed(evt);
            }
        });

        GrupButoane.add(Bubble);
        Bubble.setFont(FontMenu);
        Bubble.setText("Bubble");
        Bubble.setNextFocusableComponent(Selection);
        Bubble.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BubbleActionPerformed(evt);
            }
        });

        GrupButoane.add(Selection);
        Selection.setFont(FontMenu);
        Selection.setText("Selection");
        Selection.setNextFocusableComponent(Swap);
        Selection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SelectionActionPerformed(evt);
            }
        });

        GrupButoane.add(Swap);
        Swap.setFont(FontMenu);
        Swap.setText("Swap");
        Swap.setNextFocusableComponent(Heap);
        Swap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SwapActionPerformed(evt);
            }
        });

        GrupButoane.add(Heap);
        Heap.setFont(FontMenu);
        Heap.setText("Heap");
        Heap.setNextFocusableComponent(BST);
        Heap.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                HeapActionPerformed(evt);
            }
        });

        GrupButoane.add(BST);
        BST.setFont(FontMenu);
        BST.setText("BST");
        BST.setNextFocusableComponent(Counting);
        BST.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BSTActionPerformed(evt);
            }
        });

        GrupButoane.add(Counting);
        Counting.setFont(FontMenu);
        Counting.setText("Counting");
        Counting.setNextFocusableComponent(Bucket);
        Counting.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CountingActionPerformed(evt);
            }
        });

        GrupButoane.add(Bucket);
        Bucket.setFont(FontMenu);
        Bucket.setText("Bucket");
        Bucket.setNextFocusableComponent(Radix);
        Bucket.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BucketActionPerformed(evt);
            }
        });

        GrupButoane.add(Radix);
        Radix.setFont(FontMenu);
        Radix.setText("Radix");
        Radix.setNextFocusableComponent(Flipping);
        Radix.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RadixActionPerformed(evt);
            }
        });

        GrupButoane.add(Flipping);
        Flipping.setFont(FontMenu);
        Flipping.setText("Flipping");
        Flipping.setNextFocusableComponent(Intermediari);
        Flipping.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FlippingActionPerformed(evt);
            }
        });

        Intermediari.setFont(FontMenu);
        Intermediari.setSelected(true);
        Intermediari.setText("Arată pașii");
        Intermediari.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        Intermediari.setNextFocusableComponent(Executa);

        EtichetaComplexitate.setFont(FontMenu);
        EtichetaComplexitate.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        EtichetaComplexitate.setText("Complexitatea algoritmului selectat");
        EtichetaComplexitate.setFocusable(false);

        EtichetaCNef.setFont(FontMenu);
        EtichetaCNef.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        EtichetaCNef.setText("Nefavorabil");
        EtichetaCNef.setFocusable(false);

        EtichetaCMed.setFont(FontMenu);
        EtichetaCMed.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        EtichetaCMed.setText("Mediu");
        EtichetaCMed.setFocusable(false);

        EtichetaCFav.setFont(FontMenu);
        EtichetaCFav.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        EtichetaCFav.setText("Favorabil");
        EtichetaCFav.setFocusable(false);

        Nefavorabil.setEditable(false);
        Nefavorabil.setFont(FontMenu);
        Nefavorabil.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        Nefavorabil.setText("O(n·log(n))");
        Nefavorabil.setFocusable(false);

        Mediu.setEditable(false);
        Mediu.setFont(FontMenu);
        Mediu.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        Mediu.setText("O(n·log(n))");
        Mediu.setFocusable(false);

        Favorabil.setEditable(false);
        Favorabil.setFont(FontMenu);
        Favorabil.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        Favorabil.setText("O(n·log(n))");
        Favorabil.setFocusable(false);

        Executa.setFont(FontMenu);
        Executa.setText("Execută sortarea");
        Executa.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        Executa.setNextFocusableComponent(ListaRezultat);
        Executa.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExecutaActionPerformed(evt);
            }
        });

        EtichetaRezultat.setFont(FontMenu);
        EtichetaRezultat.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        EtichetaRezultat.setText("Rezultatul sortării");
        EtichetaRezultat.setFocusable(false);

        jScrollPane2.setFocusable(false);

        ListaRezultat.setEditable(false);
        ListaRezultat.setColumns(20);
        ListaRezultat.setFont(FontText);
        ListaRezultat.setRows(5);
        ListaRezultat.setNextFocusableComponent(ListaNumere);
        jScrollPane2.setViewportView(ListaRezultat);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(Counting, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(BST, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Heap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Swap, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Selection, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Bubble, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Insertion, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Quick, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Merge, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Bucket, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Radix, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Flipping, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(Intermediari, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                        .addComponent(EtichetaComplexitate, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addGroup(layout.createSequentialGroup()
                                            .addComponent(EtichetaCNef, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(EtichetaCMed, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                            .addComponent(EtichetaCFav, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(layout.createSequentialGroup()
                                        .addComponent(Nefavorabil, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(Mediu, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(Favorabil, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(Executa, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addComponent(Separator)
                            .addComponent(EtichetaRezultat, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(jScrollPane2)))
                    .addComponent(Instructiuni, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Instructiuni, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Merge)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Quick)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Insertion)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Bubble)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Selection, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Swap, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Heap)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(BST)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Counting)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Bucket)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Radix)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Flipping)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Intermediari)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(Executa, javax.swing.GroupLayout.PREFERRED_SIZE, 73, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(EtichetaComplexitate)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(EtichetaCFav)
                                    .addComponent(EtichetaCNef)
                                    .addComponent(EtichetaCMed))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(Nefavorabil, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(Mediu, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(Favorabil, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(Separator, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(EtichetaRezultat, javax.swing.GroupLayout.PREFERRED_SIZE, 22, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jScrollPane2)))
                .addContainerGap())
        );

        this.Merge.setActionCommand("Merge");
        this.Quick.setActionCommand("Quick");
        this.Insertion.setActionCommand("Insertion");
        this.Bubble.setActionCommand("Bubble");
        this.Selection.setActionCommand("Selection");
        this.Swap.setActionCommand("Swap");
        this.Heap.setActionCommand("Heap");
        this.BST.setActionCommand("BST");
        this.Counting.setActionCommand("Counting");
        this.Bucket.setActionCommand("Bucket");
        this.Radix.setActionCommand("Radix");
        this.Flipping.setActionCommand("Flipping");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void QuickActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_QuickActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n·log(n))");
        Favorabil.setText("O(n·log(n))");
    }//GEN-LAST:event_QuickActionPerformed

    private void MergeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MergeActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n·log(n))");
        Mediu.setText("O(n·log(n))");
        Favorabil.setText("O(n·log(n))");
    }//GEN-LAST:event_MergeActionPerformed

    private void InsertionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_InsertionActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n²)");
        Favorabil.setText("O(n)");
    }//GEN-LAST:event_InsertionActionPerformed

    private void BubbleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BubbleActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n²)");
        Favorabil.setText("O(n)");
    }//GEN-LAST:event_BubbleActionPerformed

    private void SelectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SelectionActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n²)");
        Favorabil.setText("O(n²)");
    }//GEN-LAST:event_SelectionActionPerformed

    private void SwapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SwapActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n²)");
        Favorabil.setText("O(n²)");
    }//GEN-LAST:event_SwapActionPerformed

    private void HeapActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_HeapActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n·log(n))");
        Mediu.setText("O(n·log(n))");
        Favorabil.setText("O(n·log(n))");
    }//GEN-LAST:event_HeapActionPerformed

    private void BSTActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BSTActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(n·log(n))");
        Favorabil.setText("O(n·log(n))");
    }//GEN-LAST:event_BSTActionPerformed

    private void CountingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CountingActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(k+n)");
        Mediu.setText("O(k+n)");
        Favorabil.setText("O(k+n)");
    }//GEN-LAST:event_CountingActionPerformed

    private void BucketActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BucketActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n²)");
        Mediu.setText("O(k+n)");
        Favorabil.setText("O(k+n)");
    }//GEN-LAST:event_BucketActionPerformed

    private void RadixActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RadixActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(d(k+n))");
        Mediu.setText("O(d(k+n))");
        Favorabil.setText("O(d(k+n))");
    }//GEN-LAST:event_RadixActionPerformed

    private void FlippingActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FlippingActionPerformed
        // TODO add your handling code here:
        Nefavorabil.setText("O(n)");
        Mediu.setText("O(n)");
        Favorabil.setText("O(n)");
    }//GEN-LAST:event_FlippingActionPerformed

    /**
     * Parametru global pentru generarea textului ce urmează a fi afișat
     * ca rezultat.
     * Se utilizează StringBuilder în loc de String pentru că dacă avem un string a
     * și efectuăm operațiunea a += "textnou", se alocă spațiu de memorie în plus
     * pentru noul string care e rezultatul concatenării lui a cu "textnou".
     * StringBuilder funcționează ca un buffer din care vom lua rezultatul final.
     */
    public StringBuilder blob;

    /**
     * Procedură de interschimbare a două valori din două poziții ale unui vector
     * Interesant e că nu e nevoie de o alocare a unei variabile auxiliare
     * @param array
     * @param i
     * @param j
     */
    public void swaparray(int[] array, int i, int j) {
        array[i] = (array[i] + array[j]) - (array[j] = array[i]);
    }

    /**
     * Funcție de parsare și de calcul a dimensiunii maxime a vectorului
     * de numere conținut de stringul parametru.
     * @param array
     * @return
     */
    public int dimensiune(String array) {
        int max = array.length();
        char ch[] = array.toCharArray();
        int i = 0;
        int k = 0;
        while (i < (max-1)) {
            if (!(ch[i] == '-')) {
                if ((ch[i] >= '0') && (ch[i] <= '9')) {
                    k++;
                    while ((ch[i] >= '0') && (ch[i] <= '9') && (i < (max-1))) {
                        i++;
                    }
                } else {
                    i++;
                }
            } else {
                if ((ch[i+1] >= '0') && (ch[i+1] <= '9')) {
                    k++;
                    i++;
                    while ((ch[i] >= '0') && (ch[i] <= '9') && (i < (max-1))) {
                        i++;
                    }
                } else {
                    i++;
                }
            }
        }
        return k;
    }

    /**
     * Funcție de conversie a vectorului cu numere întregi sub forma
     * "{ v0 , v1, ...., vN }" de tip string
     * @param array
     * @return 
     */
    public String conversieI(int[] array) {
        int len = array.length;
        StringBuilder conv = new StringBuilder();
        conv.append("{");
        if (len > 0) {
            for(int i = 0; i < (len - 1); i++) {
                conv.append(array[i] + ",");
            }
            conv.append(array[len - 1]);
        }
        conv.append("}");
        return conv.toString();
    }

    /**
     * Funcție de interclasare a doi vectori
     * @param left
     * @param right
     * @return 
     */
    public int[] merge(int[] left, int[] right) {
        int l = 0;
        int r = 0;
        int k = 0;
        int maxleft = left.length;
        int maxright = right.length;
        int maxresult = maxleft + maxright;
        int[] result =  new int[maxresult];
        while ((l < maxleft) && (r < maxright)) {
            if (left[l] > right[r]) {
                result[k] = right[r];
                r += 1;
                k += 1;
            } else {
                if (left[l] < right[r]) {
                    result[k] = left[l];
                    l += 1;
                    k += 1;
                } else {
                    result[k] = left[l];
                    result[k+1] = right[r];
                    l += 1;
                    r += 1;
                    k += 2;
                }
            }
        }
        /* Adăugam la final ce a rămas neparcurs din vectori  */
        while (l < maxleft) {
            result[k] = left[l];
            l += 1;
            k += 1;
        }
        while (r < maxright) {
            result[k] = right[r];
            r += 1;
            k += 1;
        }
        if (Intermediari.isSelected()) {
            blob.append("   - Interclasare: ").append(conversieI(result)).append("\n");
        }
        return result;
    }

    /**
     * Funcția recursivă Merge_Sort
     * @param array
     * @return 
     */
    public int[] Merge_Sort(int[] array) {
        int len = array.length;
        if (len < 2) {
            return array;
        }
        int[] left = Arrays.copyOfRange(array, 0, len / 2);
        int[] right = Arrays.copyOfRange(array, (len / 2), len);
        if (Intermediari.isSelected()) {
            blob.append("\n - Stânga: ").append(conversieI(left)).append(" Dreapta: ").append(conversieI(right)).append("\n");
        }
        return merge(Merge_Sort(left),Merge_Sort(right));
    }

    /**
     * Funcție de concatenare a trei vectori
     * @param array1
     * @param array2
     * @param array3
     * @return 
     */
    public int[] concat3arraysI(int[] array1, int[] array2, int[] array3) {
        int len1;
        int len2;
        int len3;
        if (array1 == null) len1 = 0;
        else len1 = array1.length;
        if (array2 == null) len2 = 0;
        else len2 = array2.length;
        if (array3 == null) len3 = 0;
        else len3 = array3.length;
        int len = len1 + len2 + len3;
        if (len == 0) return null;
        int[] result =  new int[len];
        int k = 0;
        int i;
        for(i = 0; i < len1; i += 1) {
            result[k] = array1[i];
            k += 1;
        }
        for(i = 0; i < len2; i += 1) {
            result[k] = array2[i];
            k += 1;
        }
        for(i = 0; i < len3; i += 1) {
            result[k] = array3[i];
            k += 1;
        }
        return result;
    }

    /**
     * Funcție de adăugarea un element "value" la finalul unui vector
     * @param array
     * @param value
     * @return 
     */
    public int[] appendI(int[] array, int value) {
        if (array == null) {
            int[] result = new int[1];
            result[0] = value;
            return result;
        }
        int[] result = Arrays.copyOf(array, array.length + 1);
        result[array.length] = value;
        return result;
    }

    /**
     * Funcția recursivă Quick Sort
     * @param array
     * @return 
     */
    public int[] Quick_Sort(int[] array) {
        int len = array.length;
        if (len < 2) {
            return array;
        }
        int[] pivot =  new int[1];
        pivot[0] = array[len - 1];
        int[] left =  new int[0];
        int[] right =  new int[0];
        for(int i = 0; i < (len - 1); i += 1) {
            if (array[i] <= pivot[0]) {
                left = appendI(left,array[i]);
            } else {
                right = appendI(right,array[i]);
            }
        }
        if (Intermediari.isSelected()) {
            blob.append("\n Stânga: ").append(conversieI(left)).append(" Pivot: ").append(conversieI(pivot)).append(" Dreapta: ").append(conversieI(right)).append("\n");
            if ((left.length <= 1) && (right.length > 1)) {
                blob.append(" - Se va continua cu sortarea rapidă doar a numerelor din dreapta\n");
            }
            if ((left.length > 1) && (right.length <= 1)) {
                blob.append(" - Se va continua cu sortarea rapidă doar a numerelor din stânga\n");
            }
            if ((left.length > 1) && (right.length > 1)) {
                blob.append(" - Se va continua cu sortarea rapidă a numerelor din stânga și dreapta\n");
            }
        }
        return concat3arraysI(Quick_Sort(left), pivot, Quick_Sort(right));
    }

    /**
     * Funcția de sortare prin inserție
     * @param array
     * @return 
     */
    public int[] Insertion_Sort(int[] array) {
        int len = array.length;
        int key;
        int j;
        boolean passed;
        for(int i = 1; i < len; i += 1) {
            key = array[i];
            if (Intermediari.isSelected()) {
                blob.append("\n - Se verifică dacă numărul {").append(key).append("} poate fi inserat\n");
            }
            j = i - 1;
            passed = false;
            while ((j >= 0) && (array[j] > key)){
                array[(j + 1)] = array[j];
                j -= 1;
                passed = true;
            }
            if (passed) {
                array[(j + 1)] = key;
                if (Intermediari.isSelected()) {
                    blob.append(" - Numărul inserat: {").append(key).append("} => ").append(conversieI(array)).append("\n");
                }
            }
            if (!passed && Intermediari.isSelected()) {
                blob.append(" - Nu este necesară inserția numărului {").append(key).append("}\n");
            }
        }
        if (Intermediari.isSelected()) {
            blob.append("\n - Procesul de sortare a ajuns la final\n");
        }
        return array;
    }

    /**
     * Funcția de sortare prin metoda bulelor
     * @param array
     * @return 
     */
    public int[] Bubble_Sort(int[] array) {
        int len = array.length;
        boolean schimbare = false;
        int k = 1;
        do {
            if (Intermediari.isSelected()) {
                if (!schimbare) {
                    blob.append("\n - Începem cu primul element din vector\n");
                } else {
                    blob.append("\n - Reluăm procesul de la începutul vectorului\n");
                }
            }
            schimbare = false;
            for(int j = 0; j < (len - 1); j += 1) {
                if(array[j] > array[j + 1]) {
                    swaparray(array, j, j + 1);
                    schimbare = true;
                }
            }
            if (Intermediari.isSelected()) {
                blob.append("   - După trecerea numărul ").append(k).append(", vectorul se prezintă astfel:\n     ").append(conversieI(array)).append("\n");
            }
            k += 1;
        } while (schimbare);
        if (Intermediari.isSelected()) {
            blob.append(" - Procesul de sortare a ajuns la final\n");
        }
        return array;
    }

    /**
     * Funcția de sortare prin selecție
     * @param array
     * @return 
     */
    public int[] Selection_Sort(int[] array) {
        int len = array.length;
        int jminval;
        for(int i = 0; i < (len - 1); i += 1) {
            jminval = i;
            if (Intermediari.isSelected()) {
                blob.append("\n - Încercăm să găsim numărul minim în intervalul [").append((i + 1)).append(" .. ").append(len).append("]\n");
            }                
            for(int j = (len - 1);  j > i; j -= 1) {
                if (array[jminval] > array[j]) {
                    jminval = j;
                }
            }
            if (!(jminval == i)) {
                swaparray(array, jminval, i);
                if (Intermediari.isSelected()) {
                    blob.append("   - Numărul minim selectat este {").append(array[i]).append("} și se interschimbă cu {").append(array[jminval]).append("} => ").append(conversieI(array)).append("\n");
                }                
            }
        }
        if (Intermediari.isSelected()) {
            blob.append("\n - Procesul de sortare a ajuns la final\n");
        }
        return array;
    }

    /**
     * Funcția de sortare prin interschimbare
     * @param array
     * @return 
     */
    public int[] Swap_Sort(int[] array) {
        int i, j;
        int len = array.length;
        for(i = 0; i < len-1; i += 1) {
            if (Intermediari.isSelected()) {
                if (i == 0) {
                    blob.append("\n - Începem cu primul element din vector\n");
                } else {
                    blob.append("\n - Reluăm procesul de la poziția ").append((i + 1)).append("\n");
                }
            }
            for(j = i + 1; j < len; j += 1) {
                if (array[i] > array[j]) {
                    swaparray(array, i, j);
                }
            }
            if (Intermediari.isSelected()) {
                blob.append("   - După comparațiile succesive între elementul de pe poziția ").append((i + 1)).append(" și numerele următoare, vectorul arată astfel:\n      ").append(conversieI(array)).append("\n");
            }                
        }
        if (Intermediari.isSelected()) {
            blob.append("\n - Procesul de sortare a ajuns la final\n");
        }
        return array;
    }

    /**
     * Procedură pentru a sorta un sub-arbore cu rădăcina în 'i' care este
     * un index din vectorul 'array'. 'n' este dimensiunea masivului.
     * @param array
     * @param n
     * @param i
     * @param s
     */
    public void Heapify(int[] array, int n, int i, String s) {
        int max = i; // Presupunem că poziția curentă i este (sub)rădăcină
        int l = 2 * i + 1; // calculăm poziția elementului din stânga
        int r = 2 * i + 2; // calculăm poziția elementului din dreapta
        if ((l < n) && (array[l] > array[max])) {
            // dacă există elementul din stânga și e mai mare decât rădăcina
            max = l;
        }
        if ((r < n) && (array[r] > array[max])) {
            // dacă există elementul din dreapta și e mai mare decât rădăcina
            max = r;
        }
        if (max != i) {
            // dacă rădăcina i nu e maximul se interschimbă cu elementul maxim din l sau r
            swaparray(array, i, max);
            if (Intermediari.isSelected()) {
                blob.append("\n").append(s).append(" - Noul maxim este {").append(array[i]).append("} și se mută de pe poziția ").append((max + 1)).append(" pe poziția ").append((i + 1));
                blob.append("\n").append(s).append(" - Vectorul după interschimbarea rădăcinii: ").append(conversieI(array)).append("\n");
            }                
            // sortează recursiv sub-arborele
            Heapify(array, n, max, s + "  ");
        }        
    }

    /**
     * Funcția de sortare prin masivizarea vectorului
     * @param array 
     * @return  
     */
    public int[] Heap_Sort(int[] array) {
        int len = array.length;
        // construiește masivul (rearanjează vectorul)
        if (Intermediari.isSelected()) {
            blob.append("\n Se începe cu rearanjarea elementelor vectorului sub forma unui masiv\n");
        }                
        for(int i = (len/2 - 1); i >= 0; i -= 1) {
            Heapify(array, len, i, "");
        }
        if (Intermediari.isSelected()) {
            blob.append("\n Vectorul după rearanjarea sa: ").append(conversieI(array)).append("\n\n Se continuă cu extragerea a câte un element din masiv:\n");
        }                
        // unul câte unul extrage câte un element din masiv
        for(int i = (len - 1); i >= 0; i -= 1) {
            // schimbă rădăcina curentă la sfârșit
            if (Intermediari.isSelected()) {
                blob.append("\n   - Elementul radacină de pe poziția 0 din vectorul ").append(conversieI(array)).append(" se mută la finalul vectorului\n");
            }
            swaparray(array, 0, i);
            // apelează masivizarea maximă pe masivul redus
            if (Intermediari.isSelected()) {
                blob.append("\n - Sortăm arborele cu rădăcina {").append(array[0]).append("} de pe poziția 1 a vectorului: ").append(conversieI(array)).append("\n");
            }
            Heapify(array, i, 0, "");
        }
        if (Intermediari.isSelected()) {
            blob.append("\n - Procesul de sortare a ajuns la final\n");
        }
        return array;
    }

    /**
     * Clasă pentru structura unui arbore
     */
    public class Node {
        int data;
        // Variabila următoare este ajutătoare pentru construirea imaginii arborelui
        int level;
        Node left = null;
        Node right = null;
    }

    /**
     * Calculează nivelul maxim al arborelui 
     * @param tree
     * @return
     */
    public int MaxLevel_recursive(Node tree) {
        int MaxLevel = tree.level;
        if (tree.left != null) {
            MaxLevel = Math.max(MaxLevel, MaxLevel_recursive(tree.left));
        }
        if (tree.right != null) {
            MaxLevel = Math.max(MaxLevel, MaxLevel_recursive(tree.right));
        }
        return MaxLevel;
    }

    /**
     * Procedură de inserare a valorilor în arbore
     * @param tree
     * @param value 
     */
    public void InsertTree(Node tree, int value) {
        Node y = tree;
        // Variabilă de control (dacă value a fost inserat)
        boolean append = false;
        int nivel = 1;
        do
            // Dacă value este mai mic sau egal cu valoarea din nodul curent
            if (value <= y.data) {
                // Dacă nodul stâng nu există atunci aici vom insera value
                if (y.left == null) {
                    y.left = new Node();
                    y.left.data = value;
                    y.left.level = nivel;
                    append = true;
                    if (Intermediari.isSelected()) {
                        blob.append(" - Introducem {").append(value).append("} sub nodul {").append(y.data).append("} la stânga\n");
                    }
                } else {
                    // Altfel mergem la nodul următor din ramura stângă
                    y = y.left;
                    nivel += 1;
                }
            } else {
                // Dacă nodul drept nu există atunci aici vom insera value
                if (y.right == null) {
                    y.right = new Node();
                    y.right.data = value;
                    y.right.level = nivel;
                    append = true;
                    if (Intermediari.isSelected()) {
                        blob.append(" - Introducem {").append(value).append("} sub nodul {").append(y.data).append("} la dreapta\n");
                    }
                } else {
                    // Altfel mergem la nodul următor din ramura dreaptă
                    y = y.right;
                    nivel += 1;
                }
            }
        while (!(append));
    }

    /**
     * Funcția recursivă de parcurgere inordine a unui arbore binar
     * @param tree
     * @return
     */
    public int[] BST_recursive(Node tree) {
        // Luăm în y nodul curent ca nod rădăcină
        Node y = tree;
        // Inițializăm vectorul rezultat cu null
        int[] arrayr = new int[0];
        if (y != null) {
            // Dacă nodul curent nu este null adăugăm în vectorul rezultat valoarea din nod
            arrayr = appendI(arrayr, y.data);
            // Returnăm rezultatul recursiv compus din vectorul rezultat din brațul stâng,
            // valoarea din nodul curent și vectorul rezultat din brațul drept
            return (concat3arraysI(BST_recursive(y.left), arrayr, BST_recursive(y.right)));
        } else {
            // Altfel returnăm un vector null (după cum a fost inițializat)
            return arrayr;
        }
    }

    /**
     * Funcție ce returnează un număr de puncte egal cu lungimea numărului x
     * @param x
     * @return 
     */
    public String points(int x) {
        int len = ("" + x).length();
        StringBuilder text = new StringBuilder(len);
        for(int i = 0; i < len; i += 1) {
            text.append(".");
        }
        return text.toString();
    }

    /**
     * Funcție recursivă pentru generarea nivelelor unui arbore
     * Poziționează pe aceeași linie nodurile de pe același nivel
     * @param tree
     * @param level
     * @return
     */
    public String Levels_recursive(Node tree, int level) {
        // Luăm în y nodul curent ca nod rădăcină
        Node y = tree;
        // Inițializăm string-ul rezultat cu null
        StringBuilder rezultat = new StringBuilder();
        if (y != null) {
            // Dacă nodul curent nu este null
            if (y.level == level) {
                // dacă suntem pe nivelul level
                // adăugăm în rezultat valoarea din nodul curent
                rezultat.append("{" + y.data + "}");
            } else {
                // altfel adunăm spațiile corespunzătoare valorii din nodul curent
                rezultat.append("." + points(y.data) + ".");
            }
            // Returnăm rezultatul recursiv compus din String-ul rezultat din brațul stâng,
            // valoarea corespunzătoare din nodul curent și String-ul rezultat din brațul drept
            return Levels_recursive(y.left, level) + rezultat + Levels_recursive(y.right, level);
        } else {
            // Altfel returnăm un String null (după cum a fost inițializat)
            return rezultat.toString();
        }
    }

    /**
     * Funcția de sortare a unui vector cu ajutorul arborilor binari
     * @param array
     * @return
     */
    public int[] BST_Sort(int[] array) {
        // Creem primul nod al arborelui
        Node treesort = new Node();
        // Inserăm în primul nod prima valoare din vector
        treesort.data = array[0];
        treesort.level = 0;
        int len = array.length;
        // Dacă dimensiunea vectorului este mai mare decât 1 atunci inserăm în arbore
        // restul vectorului
        if (len > 1) {
            if (Intermediari.isSelected()) {
                blob.append("\n Inserăm valorile vectorului într-un arbore cu radacina {").append(array[0]).append("}\n");
            }
            for(int i = 1; i < len; i += 1) {
                InsertTree(treesort,array[i]);
            }
        }
        if (Intermediari.isSelected()) {
            int MaxLevel = MaxLevel_recursive(treesort);
            for(int i = 0; i <= MaxLevel; i += 1) {
                blob.append("\nValorile de pe nivelul ").append(i).append(": ").append(Levels_recursive(treesort, i)).append("\n");
            }
            blob.append("\nConstruim vectorul sortat folosind parcurgerea arborelui în inordine (stânga - rădăcină - dreapta)\n");
        }
        
        return BST_recursive(treesort);
    }

    /**
     * Funcție ajutătoare pentru a găsi valoarea minimă din vector
     * @param array
     * @return 
     */
    public int minArray(int[] array) {
        int len = array.length;
        int minim = array[0];
        for(int i = 1; i < len; i += 1) {
            if (array[i] < minim) {
                minim = array[i];
            }
        }
        return minim;
    }

    /**
     * Funcție ajutătoare pentru a găsi valoarea maximă din vector
     * @param array
     * @return 
     */
    public int maxArray(int[] array) {
        int len = array.length;
        int maxim = array[len - 1];
        /* i pornește de la (len - 1) pentru a returna primul element din vector
           și nu ultimul */
        for(int i = len - 2; i >= 0; i -= 1) {
            if (array[i] > maxim) {
                maxim = array[i];
            }
        }
        return maxim;
    }

    /**
     * Funcție ajutătoare pentru a lucra cu un vector de numere întregi la
     * sortarea prin numărare.
     * Dacă "semn" este (-1) atunci valoarea lui "artificiu" va fi pozitivă,
     * toate numerele din vector se vor aduna cu acesta, și vor fi
     * mai mare sau egale cu 0
     * Dacă "semn" este (+1) atunci valoarea lui "artificiu" va fi negativă,
     * toate numerele din vector se vor aduna cu acesta, și vor fi
     * mai mici decât 0
     * @param array
     * @param artificiu
     * @param semn
     * @return 
     */
    public int[] convertpozitiv(int[] array, int artificiu, int semn) {
        int len = array.length;
        artificiu *= semn;
        for(int i = 0; i < len; i += 1) {
            array[i] += artificiu;
        }
        return array;
    }

    /**
     * Funcția de sortare prin numărare
     * @param array
     * @return 
     */
    public int[] Counting_Sort(int[] array) {
        // Pentru că sortarea de acest tip funcționează doar la numere mici
        // încercăm să verificăm intervalul cu care lucrăm
        // Am testat și e indicat de a lucra în intervalul [0 .. 1000]
        int minim = minArray(array);
        int maxim = maxArray(array);
        if ((maxim - minim) > 1000) return null;
        int artificiu = 0;
        if ((maxim > 1000)||(minim < 0)) {
            artificiu = minArray(array);
        }
        int len = array.length;
        int[] pozitiv =  new int[len]; 
        if (!(artificiu == 0)) {
            pozitiv = convertpozitiv(array,artificiu,-1);
            if (Intermediari.isSelected()) {
                blob.append("\n - Pentru a utiliza această metodă, vectorul de numere se adjustează în intervalul [0 .. 1000]\n");
                blob.append(" - Artificiul de calcul utilizat: vector - (").append(artificiu).append(").\n");
                blob.append(" Astfel, noul vector de numere întregi este: ").append(conversieI(pozitiv)).append("\n");
            }                
        } else {
            pozitiv = Arrays.copyOf(array, len);
        }
        int k = maxArray(pozitiv) + 1;
        int[] indxC = new int[k];
        int[] C = new int[k];
        for(int i = 0; i < len; i += 1) {
            C[pozitiv[i]] += 1;
        }
        for(int i = 0; i < k; i += 1) {
            indxC[i] += i;
        }
        if (Intermediari.isSelected()) {
            blob.append("\n Inițializăm un vector C ajutător de numărare unde C[număr_existent_în_vector] = C[număr_existent_în_vector] + 1:\n     i  = ").append(conversieI(indxC)).append("\n   C[i] = ").append(conversieI(C)).append("\n");
        }                
        /* Acum C[i] conține numărul de elemente egal cu i */
        for(int i = 1; i < k; i += 1) {
            C[i] = C[i] + C[i-1];
        }
        if (Intermediari.isSelected()) {
            blob.append("\n Vectorul C ajutător se modifică în baza valorilor inițiale C[i] = C[i] + C[i-1]:\n     i  = ").append(conversieI(indxC)).append("\n   C[i] = ").append(conversieI(C)).append("\n");
        }                
        /* Acum C[i] conține numărul de elemente mai mic sau egal cu i */
        int[] B = new int[len];
        for(int i = (len - 1); i >= 0; i -= 1) {
            B[C[pozitiv[i]] - 1] = pozitiv[i];
            C[pozitiv[i]] -= 1;
            if (Intermediari.isSelected()) {
                blob.append("\n Luăm elementul ").append((i + 1)).append(" din vector:");
                blob.append("\n - vector[").append((i + 1)).append("] = ").append(pozitiv[i]).append("; ");
                blob.append("C[").append(pozitiv[i]).append("] = ").append((C[pozitiv[i]] + 1)).append(". Inițializăm rezultatul ");
                blob.append("B[").append((C[pozitiv[i]] + 1)).append("] = ").append(pozitiv[i]);
                blob.append("\n - Stadiu intermediar vector rezultat:");
                blob.append("\n     B  = ").append(conversieI(B));
                if (!(i == 0)) { blob.append(" este rezultat intermediar"); }
                else { blob.append(" este rezultat final"); }
                blob.append("\n  vector = ").append(conversieI(pozitiv)).append("\n     i  = ").append(conversieI(indxC));
                blob.append("\n   C[i] = ").append(conversieI(C)).append(" unde C[").append(pozitiv[i]).append("] a fost decrementat cu 1\n");
            }
        }
        if (!(artificiu == 0)) {
            if (Intermediari.isSelected()) {
                blob.append("\n Revenim la valorile inițiale adunând artificiul: ").append(artificiu).append("\n");
            }                
            array = convertpozitiv(B,artificiu,1);
        } else {
            array = Arrays.copyOf(B, len);
        }
        return array;
    }

    /**
     * Funcția de sortare de pachete prin inserție cu valori întregi
     * @param array
     * @return 
     */
    public int[] Stable_Sort(int[] array) {
        /* Luăm în calcul și dacă vectorul e nul */
        if (array == null) return null;
        int len = array.length;
        int key;
        for(int i = 1; i < len; i += 1) {
            key = array[i];
            int j;
            for(j = i - 1; (j >= 0) && (array[j] > key); j -= 1){
                array[(j + 1)] = array[j];
            }
            array[(j + 1)] = key;
        }
        return array;
    }

    /**
     * Funcție ce verifică dacă doi vectori cu valori întregi au aceleași valori
     * pe aceeași poziții sau nu
     * @param array1
     * @param array2
     * @return 
     */
    public boolean CheckArraysI(int[] array1, int[] array2) {
        int len1 = array1.length;
        int len2 = array2.length;
        if (!(len1 == len2)) return false;
        for(int i = 0; i < len1; i += 1) {
            if (!(array1[i] == array2[i])) return false;
        }
        return true;
    }

    /**
     * Funcția de sortare prin utilizarea de pachete
     * @param array
     * @return 
     */
    public int[] Bucket_Sort(int[] array) {
        int artificiu = minArray(array);
        int len = array.length;
        int i;
        int[] pozitiv =  new int[len]; 
        if (artificiu < 0) {
            pozitiv = convertpozitiv(array,artificiu,-1);
            if (Intermediari.isSelected()) {
                blob.append("\n - Pentru a avea doar numere pozitive în vectorul de numere, utilizăm un artificiu:\n");
                blob.append(" - Scădem toate valorile vectorului cu valoarea cea mai mică din vector (mai mică decât 0).\n");
                blob.append(" - Artificiul de calcul utilizat: vector - (").append(artificiu).append(").\n");
                blob.append(" Astfel, noul vector de numere întregi este: ").append(conversieI(pozitiv)).append("\n");
            }                
        } else {
            pozitiv = Arrays.copyOf(array, len);
        }
        // ! Varianta inițială avea probleme la transformarea din "int" în "double"
        // ! La valori mari, vectorul de numere reale pierdea niște cifre
        // ! poziționate după virgulă
        // Lungimea maximă a numărului minus unu
        int lenmax = (String.valueOf(maxArray(pozitiv)).length()) - 1;
        // Puterea lui zece la care imparțim toate numerele vectorului
        double zece = Math.pow(10.0, lenmax);
        if (Intermediari.isSelected()) {
            blob.append("\n - Sortarea elementelor se va efectua în funcție de valoarea fiecărui elementele din vector împărțit la ").append(((int) zece)).append(".\n");
        }
        /* Inițializare pachete */
        int[] bucket[] = new int[10][0];
        int selectie;
        /* Adăugare valori în pachete */
        for(i = 0; i < len; i += 1) {
            selectie = (int)(((double)(pozitiv[i]))/zece);
            bucket[selectie] = appendI(bucket[selectie], pozitiv[i]);
        }
        int[] concatenated = new int[0];
        /* Sortare și concatenare */
        for(i = 0; i < 10; i += 1) {
            if (Intermediari.isSelected()) {
                blob.append("\n   - Pachetul ").append((i + 1)).append(" conține următoarele elemente nesortate: ").append(conversieI(bucket[i])).append("\n");
            }
            /* Sortare pachete */
            int[] tempbucket = Arrays.copyOf(bucket[i], bucket[i].length);
            bucket[i] = Stable_Sort(bucket[i]);
            if (Intermediari.isSelected()) {
                if (CheckArraysI(bucket[i],tempbucket)) {
                    blob.append("     - Nu a fost necesară sortarea\n");
                } else {
                    blob.append("     - După sortare conține următoarele elemente: ").append(conversieI(bucket[i])).append("\n");
                }
            }
            /* Concatenare pachete */
            concatenated = concat2arraysI(concatenated, bucket[i]);
        }
        pozitiv = Arrays.copyOf(concatenated, len);
        if (Intermediari.isSelected()) {
            blob.append("\n Pachetele concatenate sunt: ").append(conversieI(pozitiv)).append("\n");
        }
        if (artificiu < 0) {
            if (Intermediari.isSelected()) {
                blob.append("\n Revenim la valorile inițiale adunând artificiul: ").append(artificiu).append("\n");
            }                
            array = convertpozitiv(pozitiv,artificiu,1);
        } else {
            array = Arrays.copyOf(pozitiv, len);
        }
        return array;
    }

    /**
     * Funcție de concatenare a doi vectori cu valori întregi
     * @param array1
     * @param array2
     * @return 
     */
    public int[] concat2arraysI(int[] array1, int[] array2) {
        int len1;
        int len2;
        if (array1 == null) len1 = 0;
        else len1 = array1.length;
        if (array2 == null) len2 = 0;
        else len2 = array2.length;
        int len = len1 + len2;
        /* Dacă cei doi vectori sunt nuli */
        if (len == 0) return null;
        int[] result =  new int[len];
        int k = 0;
        int i;
        for(i = 0; i < len1; i += 1) {
            result[k] = array1[i];
            k += 1;
        }
        for(i = 0; i < len2; i += 1) {
            result[k] = array2[i];
            k += 1;
        }
        return result;
    }

    /**
     * Funcția de sortare prin metoda radix
     * Sortarea se face începând de la cifra cea mai puțin semnificativă (dreapta)
     * și continuă până ajunge la cifra cea mai semnificativă (stânga)
     * @param array
     * @return 
     */
    public int[] Radix_Sort(int[] array) {
        int artificiu = minArray(array);
        int len = array.length;
        int i,j,selectie;
        double zece_i;
        int[] pozitiv =  new int[len]; 
        if (artificiu < 0) {
            pozitiv = convertpozitiv(array,artificiu,-1);
            if (Intermediari.isSelected()) {
                blob.append("\n - Pentru a avea doar numere pozitive în vectorul de numere, utilizăm un artificiu:\n");
                blob.append(" - Scădem toate valorile vectorului cu valoarea cea mai mică din vector (mai mică decât 0).\n");
                blob.append(" - Artificiul de calcul utilizat: vector - (").append(artificiu).append(").\n");
                blob.append(" Astfel, noul vector de numere întregi este: ").append(conversieI(pozitiv)).append("\n");
            }                
        } else {
            pozitiv = Arrays.copyOf(array, len);
        }
        int lenmax = String.valueOf(maxArray(pozitiv)).length();
        for(i = 0; i < lenmax; i += 1) {
            if (Intermediari.isSelected()) {
                blob.append("\n  Sortam vectorul în funcție de cifra numărul ").append((i + 1)).append(" de la dreapta la stânga:\n");
            }
            zece_i = Math.pow(10.0, i);
            /* Inițializăm pachetele */
            int[][] bucket = new int[10][0];
            for(j = 0; j < len; j += 1) {
                // potrivirea pachetelor in funcție de calculul (val/10^i)%10 care
                // are ca rezultat cifra i din numărul val de la stânga la dreapta
                selectie = ((int)(((double)(pozitiv[j]))/zece_i)) % 10;
                bucket[selectie] = appendI(bucket[selectie], pozitiv[j]);
            }
            int[] concatenated = new int[0];
            /* Concatenare */
            for(j = 0; j < 10; j +=1) {
                if (Intermediari.isSelected()) {
                    blob.append("   - Pachetul ").append((j + 1)).append(" conține următoarele elemente: ").append(conversieI(bucket[j])).append("\n");
                }
                /* Concatenare pachete */
                concatenated = concat2arraysI(concatenated, bucket[j]);
            }
            pozitiv = Arrays.copyOf(concatenated, len);
            if (Intermediari.isSelected()) {
                blob.append(" - După concatenare vectorul conține următoarele elemente: ").append(conversieI(pozitiv)).append("\n");
            }
        }
        if (artificiu < 0) {
            if (Intermediari.isSelected()) {
                blob.append("\n Revenim la valorile inițiale adunând artificiul: ").append(artificiu).append("\n");
            }                
            array = convertpozitiv(pozitiv,artificiu,1);
        } else {
            array = Arrays.copyOf(pozitiv, len);
        }
        return array;
    }

    /**
     * Procedură de inversare a vectorului în intervalul [0 .. indx]
     * @param array
     * @param indx
     */
    public void flip(int[] array, int indx) {
        int i = 0;
        while (i < indx) {
            swaparray(array, i, indx);
            i += 1;
            indx -= 1;
        }
    }

    /**
     * Funcție ajutătoare pentru a găsi poziția valoarii maxime din vector
     * în intervalul [0 .. indx]
     * @param array
     * @param indx
     * @return 
     */
    public int maxArrayPos(int[] array, int indx) {
        int maxim = 0;
        /* i pornește de la 0 pentru a evita o interogare (indx = 1) */
        for(int i = 0; i < indx; i += 1) {
            if (array[i] > array[maxim]) {
                maxim = i;
            }
        }
        return maxim;
    }

    /**
     * Funcția de sortare prin metoda răsturnării
     * @param array
     * @return 
     */
    public int[] Flipping_Sort(int[] array) {
        int len = array.length;
        /* Se începe de la vectorul complet și reducem mărimea sa câte un increment */
        for(int i = len; i > 1; --i) {
            /* Găsim elementul de valoare maximă în intervalul [0 .. i-1] */
            int maxpos = maxArrayPos(array, i);
            if (Intermediari.isSelected()) {
                blob.append("\n - Găsim în intervalul [1 .. ").append(i).append("] elementul maxim {").append(array[maxpos]).append("} pe poziția ").append((maxpos+1)).append("\n");
            }                
            /* Mutăm elementul maxim la sfârșit dacă nu este deja acolo */
            if (maxpos != (i-1)) {
                /* Ca să-l mutăm la sfârșit, întâi mutăm maximul la început */
                if (maxpos != 0) {
                    flip(array, maxpos);
                    if (Intermediari.isSelected()) {
                        blob.append("   - Răsturnăm intervalul [1 .. ").append((maxpos+1)).append("] => ").append(conversieI(array)).append("\n");
                    }                
                } else {
                    if (Intermediari.isSelected()) {
                        blob.append("   - Nu este necesară răsturnarea intervalului [1 .. ").append((maxpos+1)).append("]\n");
                    }                
                }
                /* Acum mutăm maximul la sfârșit răsturnând vectorul */
                flip(array, i-1);
                if (Intermediari.isSelected()) {
                    blob.append("   - Răsturnăm intervalul [1 .. ").append(i).append("] => ").append(conversieI(array)).append("\n");
                }                
            } else {
                if (Intermediari.isSelected()) {
                    blob.append("   - Elementul maxim {").append(array[maxpos]).append("} se găsește deja la sfârșitul intervalului [1 .. ").append(i).append("]\n");
                }                
            }
        }
        return array;
    }
    
    private void ExecutaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExecutaActionPerformed
        String array = ListaNumere.getText() + " ";
        int maxdim = dimensiune(array);
        blob = new StringBuilder();
        if (maxdim == 0) {
            blob.append("Nu s-a detectat nici un număr în textul introdus!");
        } else {
            int[] arlist =  new int[maxdim];
            char[] ch = array.toCharArray();
            int i = 0;
            int k = -1;
            int max = array.length();
            while (i < max-1) {
                if (!(ch[i] == '-')) {
                    if  (((ch[i] < '0') || (ch[i] > '9')) && (i < (max-1))) {
                        i++;
                    } else {
                        k++;
                        arlist[k] = 0;
                        while (((ch[i] >= '0') && (ch[i] <= '9')) && (i < (max-1)))  {
                            arlist[k] = arlist[k]*10 + Character.getNumericValue(ch[i]);
                            i++;
                        }    
                    }
                } else {
                    if  (((ch[i+1] < '0') || (ch[i+1] > '9')) && (i < (max-1))) {
                        i++;
                    } else {
                        k++;
                        arlist[k] = 0;
                        i++;
                        while (((ch[i] >= '0') && (ch[i] <= '9')) && (i < (max-1)))  {
                            arlist[k] = arlist[k]*10 + Character.getNumericValue(ch[i]);
                            i++;
                        }
                        arlist[k] *= -1;
                    }
                }
            }
            blob.append("Numărul total de numere întregi detectate: ").append(maxdim).append(".\n");
            if (maxdim > 1000) {
                Intermediari.setSelected(false);
            }
            blob.append("\nNumerele detectate sunt: ").append(conversieI(arlist)).append(".\n\n");
            String procedura = this.GrupButoane.getSelection().getActionCommand();
            int[] result=  new int[maxdim];
            switch(procedura) {
                case "Merge":
                    blob.append("Metoda utilizată: 'Sortarea prin interclasare'\n");
                    result = Merge_Sort(arlist);
                    break;
                case "Quick":
                    blob.append("Metoda utilizată: 'Sortarea rapidă (prin partiționare)'\n");
                    result = Quick_Sort(arlist);
                    break;
                case "Insertion":
                    blob.append("Metoda utilizată: 'Sortarea prin inserție'\n");
                    result = Insertion_Sort(arlist);
                    break;
                case "Bubble":
                    blob.append("Metoda utilizată: 'Sortarea prin metoda bulelor'\n");
                    result = Bubble_Sort(arlist);
                    break;
                case "Selection":
                    blob.append("Metoda utilizată: 'Sortarea prin selecție'\n");
                    result = Selection_Sort(arlist);
                    break;
                case "Swap":
                    blob.append("Metoda utilizată: 'Sortarea prin interschimbare'\n");
                    result = Swap_Sort(arlist);
                    break;
                case "Heap":
                    blob.append("Metoda utilizată: 'Sortarea cu ansamble (masive)'\n");
                    result = Heap_Sort(arlist);
                    break;
                case "BST":
                    blob.append("Metoda utilizată: 'Sortarea cu arbori de căutare binari'\n");
                    result = BST_Sort(arlist);
                    break;
                case "Counting":
                    blob.append("Metoda utilizată: 'Sortarea prin numărare'\n");
                    result = Counting_Sort(arlist);
                    break;
                case "Bucket":
                    blob.append("Metoda utilizată: 'Sortarea prin pachete'\n");
                    result = Bucket_Sort(arlist);
                    break;
                case "Radix":
                    blob.append("Metoda utilizată: 'Sortarea prin metoda radix'\n");
                    result = Radix_Sort(arlist);
                    break;
                case "Flipping":
                    blob.append("Metoda utilizată: 'Sortarea prin răsturnare'\n");
                    result = Flipping_Sort(arlist);
                    break;
            }
            if (result == null) {
                blob.append("\nAceastă metodă nu funcționează cu vectorul de numere introdus");
                blob.append("\nPentru a utiliza metoda, diferența dintre maximul și minimul vectorului trebuie să fie mai mic decât 1000");
            } else {
                if (maxdim > 1000) {
                    blob.append("Pentru ca memoria să nu fie suprasolicitată, se impune o măsură de siguranță. Având în vedere că numărul de elemente detectate este mai mare de 1000, pașii intermediari nu vor mai fi afișați.\n");
                }
                blob.append("\nNumerele sortate sunt: ").append(conversieI(result));
            }
        }
        ListaRezultat.setText(blob.toString());
        ListaRezultat.setCaretPosition(0);
    }//GEN-LAST:event_ExecutaActionPerformed

    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened
        // Maximizează fereastra la pornire
        setExtendedState(MAXIMIZED_BOTH);
    }//GEN-LAST:event_formWindowOpened

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(FereastraPrincipala.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(FereastraPrincipala.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(FereastraPrincipala.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(FereastraPrincipala.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new FereastraPrincipala().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JRadioButton BST;
    private javax.swing.JRadioButton Bubble;
    private javax.swing.JRadioButton Bucket;
    private javax.swing.JRadioButton Counting;
    private javax.swing.JLabel EtichetaCFav;
    private javax.swing.JLabel EtichetaCMed;
    private javax.swing.JLabel EtichetaCNef;
    private javax.swing.JLabel EtichetaComplexitate;
    private javax.swing.JLabel EtichetaRezultat;
    private javax.swing.JButton Executa;
    private javax.swing.JTextField Favorabil;
    private javax.swing.JRadioButton Flipping;
    private javax.swing.ButtonGroup GrupButoane;
    private javax.swing.JRadioButton Heap;
    private javax.swing.JRadioButton Insertion;
    private javax.swing.JLabel Instructiuni;
    private javax.swing.JCheckBox Intermediari;
    private javax.swing.JTextArea ListaNumere;
    private javax.swing.JTextArea ListaRezultat;
    private javax.swing.JTextField Mediu;
    private javax.swing.JRadioButton Merge;
    private javax.swing.JTextField Nefavorabil;
    private javax.swing.JRadioButton Quick;
    private javax.swing.JRadioButton Radix;
    private javax.swing.JRadioButton Selection;
    private javax.swing.JSeparator Separator;
    private javax.swing.JRadioButton Swap;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    // End of variables declaration//GEN-END:variables
}
